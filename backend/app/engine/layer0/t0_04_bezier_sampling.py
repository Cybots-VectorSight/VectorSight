"""T0.04 — Bézier Sampling (Boundary Point Generation).

Sample N evenly-spaced points along each path boundary.
Adaptive sampling: increase N where curvature is high, decrease where low.
This gives the LLM a pointcloud silhouette.
"""

from __future__ import annotations

import numpy as np
from svgpathtools import Path

from app.engine.context import PipelineContext
from app.engine.registry import Layer, transform

# ── Sampling constants ──
# Minimum points from parser before adaptive resampling kicks in.
# 2× ellipse DOF (5 params: cx, cy, semi-a, semi-b, θ) = 10.
_MIN_POINTS_FOR_RESAMPLE = 10
# Machine-epsilon for path length (below = degenerate path).
_PATH_LENGTH_EPSILON = 1e-10
# Sampling density range: Nyquist-derived.
# Min 200: typical icon path ~100px → 2 samples/px (Nyquist 2×).
# Max 2000: complex path ~1000px → 2 samples/px.
# Scale: 10 samples/unit-length.
_MIN_SAMPLES = 200
_MAX_SAMPLES = 2000
_SAMPLES_PER_UNIT = 10


@transform(
    id="T0.04",
    layer=Layer.PARSING,
    dependencies=["T0.03"],
    description="Sample boundary points along paths with adaptive density",
    tags={"always"},
)
def bezier_sampling(ctx: PipelineContext) -> None:
    for sp in ctx.subpaths:
        if len(sp.segments) == 0:
            continue

        # If points were already generated by the parser, use adaptive resampling
        if len(sp.points) > _MIN_POINTS_FOR_RESAMPLE:
            # Already have points from parser, but resample with higher density
            path = Path(*sp.segments)
            if path.length() < _PATH_LENGTH_EPSILON:
                continue

            total_samples = max(_MIN_SAMPLES, min(_MAX_SAMPLES, int(path.length() * _SAMPLES_PER_UNIT)))
            points: list[tuple[float, float]] = []

            for t in np.linspace(0, 1, total_samples):
                try:
                    pt = path.point(t)
                    points.append((pt.real, pt.imag))
                except Exception:
                    pass

            if len(points) >= 3:
                sp.points = np.array(points)
                sp.features["sample_count"] = len(points)

                # Rebuild polygon with denser points
                try:
                    from shapely.geometry import Polygon

                    poly = Polygon(points)
                    if not poly.is_valid:
                        poly = poly.buffer(0)
                    sp.polygon = poly
                except Exception:
                    pass

                # Update bbox
                from app.utils.geometry import bbox

                sp.bbox = bbox(sp.points)
        else:
            sp.features["sample_count"] = len(sp.points)
